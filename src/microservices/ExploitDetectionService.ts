import { ethers } from 'ethers';
import { VulnerableBank } from '../../typechain-types';

type Transaction = ethers.TransactionResponse;

interface TransactionInfo {
  hash: string;
  from: string;
  to: string | null;
  value: bigint;
  function: string;
  timestamp: number;
}

export class ExploitDetectionService {
  private provider: ethers.Provider;
  private contract: VulnerableBank;
  private contractAddress: string;
  private recentTransactions: TransactionInfo[] = [];
  private suspiciousSequences: string[] = [];
  private readonly TRANSACTION_HISTORY_LIMIT = 10;
  private readonly SUSPICIOUS_SEQUENCE_LIMIT = 5;
  private readonly TIME_WINDOW = 30000; // 30 seconds

  constructor(provider: ethers.Provider, contract: VulnerableBank) {
    this.provider = provider;
    this.contract = contract;
    this.contractAddress = '';
  }

  async startMonitoring() {
    console.log('Starting to monitor transactions...');

    try {
      this.contractAddress = await this.contract.getAddress();
      console.log('Monitoring contract at address:', this.contractAddress);

      this.provider.on('pending', (txHash) => this.analyzePendingTransaction(txHash).catch(console.error));

      console.log('Transaction monitoring set up successfully');
    } catch (error) {
      console.error('Error setting up transaction monitoring:', error);
    }
  }

  private async analyzePendingTransaction(txHash: string) {
    try {
      const tx = await this.provider.getTransaction(txHash);
      if (tx) {
        const txInfo = await this.getTransactionInfo(tx);
        this.logTransactionDetails(txInfo);
        this.updateTransactionHistory(txInfo);
        this.detectReentrancyAttack(txInfo);
      }
    } catch (error) {
      console.error(`Error analyzing pending transaction ${txHash}:`, error);
    }
  }

  private async getTransactionInfo(tx: Transaction): Promise<TransactionInfo> {
    const isToVulnerableBank = tx.to?.toLowerCase() === this.contractAddress.toLowerCase();
    let functionName = 'Unknown';

    if (isToVulnerableBank) {
      const decodedData = this.contract.interface.parseTransaction({ data: tx.data, value: tx.value });
      functionName = decodedData?.name || 'Unknown';
    } else if (!tx.to) {
      functionName = 'Contract Deployment';
    }

    return {
      hash: tx.hash,
      from: tx.from,
      to: tx.to,
      value: tx.value,
      function: functionName,
      timestamp: Date.now()
    };
  }

  private logTransactionDetails(txInfo: TransactionInfo) {
    console.log(`
Transaction Details:
  Hash: ${txInfo.hash}
  From: ${txInfo.from}
  To: ${txInfo.to}
  Function: ${txInfo.function}
  Value: ${ethers.formatEther(txInfo.value)} ETH
    `);
  }

  private updateTransactionHistory(txInfo: TransactionInfo) {
    this.recentTransactions.push(txInfo);
    if (this.recentTransactions.length > this.TRANSACTION_HISTORY_LIMIT) {
      this.recentTransactions.shift();
    }
  }

  private detectReentrancyAttack(latestTx: TransactionInfo) {
    const recentTxs = this.recentTransactions.filter(tx =>
      tx.timestamp >= latestTx.timestamp - this.TIME_WINDOW
    );

    if (recentTxs.length < 3) return; // Need at least 3 transactions for a potential attack

    const hasContractDeployment = recentTxs.some(tx => tx.function === 'Contract Deployment');
    const hasDepositToVulnerableBank = recentTxs.some(tx =>
      tx.to === this.contractAddress && tx.function === 'deposit'
    );
    const hasInteractionWithNewContract = recentTxs.some(tx =>
      tx.to !== this.contractAddress && tx.to !== null
    );
    const hasMultipleInteractions = new Set(recentTxs.map(tx => tx.to)).size > 2;

    if (hasContractDeployment && hasDepositToVulnerableBank && hasInteractionWithNewContract && hasMultipleInteractions) {
      const sequence = recentTxs.map(tx => `${tx.function}:${tx.to}`).join(' -> ');
      this.reportSuspiciousSequence(sequence, 'Potential reentrancy attack detected');
    }
  }

  private reportSuspiciousSequence(sequence: string, reason: string) {
    const report = `ALERT: ${reason}\nTransaction Sequence: ${sequence}`;
    console.log(report);
    this.suspiciousSequences.push(report);
    if (this.suspiciousSequences.length > this.SUSPICIOUS_SEQUENCE_LIMIT) {
      this.suspiciousSequences.shift();
    }
  }

  public getSuspiciousSequences(): string[] {
    return this.suspiciousSequences;
  }
}