import { ethers } from 'ethers';
import { VulnerableBank } from '../../typechain-types';
import nodemailer from 'nodemailer';
import dotenv from 'dotenv';
import EventEmitter from 'events';
import { ReportingService } from './ReportingService';

dotenv.config();

type Transaction = ethers.TransactionResponse;

interface TransactionInfo {
  hash: string;
  from: string;
  to: string | null;
  value: bigint;
  function: string;
  timestamp: number;
}

export class ExploitDetectionService extends EventEmitter {
  private provider: ethers.Provider;
  private contract: VulnerableBank;
  private contractAddress: string;
  private recentTransactions: TransactionInfo[] = [];
  private suspiciousSequences: string[] = [];
  private readonly TRANSACTION_HISTORY_LIMIT = 10;
  private readonly SUSPICIOUS_SEQUENCE_LIMIT = 5;
  private readonly TIME_WINDOW = 30000; // 30 seconds
  private emailTransporter: nodemailer.Transporter | null = null;
  private reportingService: ReportingService;

  constructor(provider: ethers.Provider, contract: VulnerableBank, reportingService: ReportingService) {
    super();
    this.provider = provider;
    this.contract = contract;
    this.contractAddress = '';
    this.reportingService = reportingService;
    this.setupEmailTransporter();
  }

  private setupEmailTransporter() {
    const { EMAIL_HOST, EMAIL_PORT, EMAIL_SECURE, EMAIL_USER, EMAIL_PASS } = process.env;

    if (EMAIL_HOST && EMAIL_USER && EMAIL_PASS) {
      this.emailTransporter = nodemailer.createTransport({
        host: EMAIL_HOST,
        port: parseInt(EMAIL_PORT || '587'),
        secure: EMAIL_SECURE === 'true',
        auth: {
          user: EMAIL_USER,
          pass: EMAIL_PASS
        }
      });
      console.log('Email transporter set up successfully');
    } else {
      console.warn('Email configuration not set. Email alerts will not be sent.');
    }
  }

  async startMonitoring() {
    console.log('Starting to monitor transactions...');

    try {
      this.contractAddress = await this.contract.getAddress();
      console.log('Monitoring contract at address:', this.contractAddress);

      this.provider.on('pending', (txHash) => this.analyzePendingTransaction(txHash).catch(console.error));

      console.log('Transaction monitoring set up successfully');
    } catch (error) {
      console.error('Error setting up transaction monitoring:', error);
    }
  }

  private async analyzePendingTransaction(txHash: string) {
    try {
      const tx = await this.provider.getTransaction(txHash);
      if (tx) {
        const txInfo = await this.getTransactionInfo(tx);
        this.logTransactionDetails(txInfo);
        this.updateTransactionHistory(txInfo);
        await this.detectReentrancyAttack(txInfo);
        await this.reportingService.logTransaction(txInfo);
      }
    } catch (error) {
      console.error(`Error analyzing pending transaction ${txHash}:`, error);
    }
  }

  private async getTransactionInfo(tx: Transaction): Promise<TransactionInfo> {
    const isToVulnerableBank = tx.to?.toLowerCase() === this.contractAddress.toLowerCase();
    let functionName = 'Unknown';

    if (isToVulnerableBank) {
      const decodedData = this.contract.interface.parseTransaction({ data: tx.data, value: tx.value });
      functionName = decodedData?.name || 'Unknown';
    } else if (!tx.to) {
      functionName = 'Contract Deployment';
    }

    return {
      hash: tx.hash,
      from: tx.from,
      to: tx.to,
      value: tx.value,
      function: functionName,
      timestamp: Date.now()
    };
  }

  private logTransactionDetails(txInfo: TransactionInfo) {
    console.log(`
Transaction Details:
  Hash: ${txInfo.hash}
  From: ${txInfo.from}
  To: ${txInfo.to}
  Function: ${txInfo.function}
  Value: ${ethers.formatEther(txInfo.value)} ETH
    `);
  }

  private updateTransactionHistory(txInfo: TransactionInfo) {
    this.recentTransactions.push(txInfo);
    if (this.recentTransactions.length > this.TRANSACTION_HISTORY_LIMIT) {
      this.recentTransactions.shift();
    }
  }

  private async detectReentrancyAttack(latestTx: TransactionInfo) {
    const recentTxs = this.recentTransactions.filter(tx =>
      tx.timestamp >= latestTx.timestamp - this.TIME_WINDOW
    );

    if (recentTxs.length < 2) return; // Need at least 2 transactions for a potential attack

    const hasDepositToVulnerableBank = recentTxs.some(tx =>
      tx.to === this.contractAddress && tx.function === 'deposit'
    );
    const hasInteractionWithNewContract = recentTxs.some(tx =>
      tx.to !== this.contractAddress && tx.to !== null
    );

    if (hasDepositToVulnerableBank && hasInteractionWithNewContract) {
      const sequence = recentTxs.map(tx => `${tx.function}:${tx.to}`).join(' -> ');

      // Emit the event immediately
      this.emit('potentialAttack', { type: 'reentrancy', sequence, latestTx });

      await this.reportSuspiciousSequence(sequence, 'Potential reentrancy attack detected');
    }
  }

  private async reportSuspiciousSequence(sequence: string, reason: string) {
    const report = `ALERT: ${reason}\nTransaction Sequence: ${sequence}`;
    console.log(report);
    this.suspiciousSequences.push(report);
    if (this.suspiciousSequences.length > this.SUSPICIOUS_SEQUENCE_LIMIT) {
      this.suspiciousSequences.shift();
    }

    await this.sendEmailAlert(report);
    await this.reportingService.logAlert('reentrancy', report);
  }

  private async sendEmailAlert(content: string) {
    if (!this.emailTransporter) {
      console.warn('Email transporter not set up. Skipping email alert.');
      return;
    }

    const { EMAIL_FROM, EMAIL_TO } = process.env;

    if (!EMAIL_FROM || !EMAIL_TO) {
      console.warn('Email sender or recipient not set. Skipping email alert.');
      return;
    }

    try {
      await this.emailTransporter.sendMail({
        from: EMAIL_FROM,
        to: EMAIL_TO,
        subject: 'Potential Reentrancy Attack Detected',
        text: content
      });
      console.log('Email alert sent successfully');
    } catch (error) {
      console.error('Error sending email alert:', error);
    }
  }

  public getSuspiciousSequences(): string[] {
    return this.suspiciousSequences;
  }
}