import { ethers } from 'ethers';
import { VulnerableBank } from '../../typechain-types';
import nodemailer from 'nodemailer';
import dotenv from 'dotenv';
import EventEmitter from 'events';
import { ReportingService } from './ReportingService';

dotenv.config();

type Transaction = ethers.TransactionResponse;
interface TransactionInfo {
  hash: string;
  from: string;
  to: string | null;
  value: bigint;
  function: string;
  timestamp: number;
  data: string;
}
export class ExploitDetectionService extends EventEmitter {
  private provider: ethers.JsonRpcProvider;
  private contract: VulnerableBank;
  private contractAddress: string;
  private recentTransactions: TransactionInfo[] = [];
  private suspiciousSequences: string[] = [];
  private readonly TRANSACTION_HISTORY_LIMIT = 50;
  private readonly SUSPICIOUS_SEQUENCE_LIMIT = 10;
  private readonly TIME_WINDOW = 30000; // 30 seconds
  private emailTransporter: nodemailer.Transporter | null = null;
  private reportingService: ReportingService;
  private isContractPaused: boolean = false;
  private pauseTransactionHash: string | null = null;
  private lastPauseAttempt: number = 0;
  private readonly PAUSE_COOLDOWN: number = 5000; // 5 seconds cooldown

  constructor(provider: ethers.JsonRpcProvider, contract: VulnerableBank, reportingService: ReportingService) {
    super();
    this.provider = provider;
    this.contract = contract;
    this.contractAddress = '';
    this.reportingService = reportingService;
    this.setupEmailTransporter();
  }

  private setupEmailTransporter() {
    const { EMAIL_HOST, EMAIL_PORT, EMAIL_SECURE, EMAIL_USER, EMAIL_PASS } = process.env;

    if (EMAIL_HOST && EMAIL_USER && EMAIL_PASS) {
      this.emailTransporter = nodemailer.createTransport({
        host: EMAIL_HOST,
        port: parseInt(EMAIL_PORT || '587'),
        secure: EMAIL_SECURE === 'true',
        auth: {
          user: EMAIL_USER,
          pass: EMAIL_PASS
        }
      });
      console.log('Email transporter set up successfully');
    } else {
      console.warn('Email configuration not set. Email alerts will not be sent.');
    }
  }

  async startMonitoring() {
    console.log('Starting to monitor transactions...');

    try {
      this.contractAddress = await this.contract.getAddress();
      console.log('Monitoring contract at address:', this.contractAddress);

      this.provider.on('pending', (txHash) => this.analyzePendingTransaction(txHash).catch(console.error));

      console.log('Transaction monitoring set up successfully');
    } catch (error) {
      console.error('Error setting up transaction monitoring:', error);
    }
  }

  private async analyzePendingTransaction(txHash: string) {
    try {
      const tx = await this.provider.getTransaction(txHash);
      if (tx) {
        const txInfo = await this.getTransactionInfo(tx);
        this.logTransactionDetails(txInfo);
        this.updateTransactionHistory(txInfo);
        await this.detectPotentialExploit(txInfo);
        await this.reportingService.logTransaction(txInfo);
      }
    } catch (error) {
      console.error(`Error analyzing pending transaction ${txHash}:`, error);
    }
  }

  private async getTransactionInfo(tx: Transaction): Promise<TransactionInfo> {
    const isToVulnerableBank = tx.to?.toLowerCase() === this.contractAddress.toLowerCase();
    let functionName = 'Unknown';

    if (isToVulnerableBank) {
      const decodedData = this.contract.interface.parseTransaction({ data: tx.data, value: tx.value });
      functionName = decodedData?.name || 'Unknown';
    } else if (!tx.to) {
      functionName = 'Contract Deployment';
    }

    return {
      hash: tx.hash,
      from: tx.from,
      to: tx.to,
      value: tx.value,
      function: functionName,
      timestamp: Date.now(),
      data: tx.data
    };
  }

  private logTransactionDetails(txInfo: TransactionInfo) {
    console.log(`
      Transaction Details:
      Hash: ${txInfo.hash}
      From: ${txInfo.from}
      To: ${txInfo.to}
      Function: ${txInfo.function}
      Value: ${ethers.formatEther(txInfo.value)} ETH
    `);
  }

  private updateTransactionHistory(txInfo: TransactionInfo) {
    this.recentTransactions.push(txInfo);
    if (this.recentTransactions.length > this.TRANSACTION_HISTORY_LIMIT) {
      this.recentTransactions.shift();
    }
  }

  private async detectPotentialExploit(latestTx: TransactionInfo) {
    const recentTxs = this.recentTransactions.filter(tx =>
      tx.timestamp >= latestTx.timestamp - this.TIME_WINDOW &&
      tx.from === latestTx.from
    );

    console.log('Recent transactions:', recentTxs.map(tx => `${tx.function} to ${tx.to}`));

    const depositTx = recentTxs.find(tx => tx.function === 'deposit' && tx.to === this.contractAddress);
    const externalInteractions = recentTxs.filter(tx => tx.to !== this.contractAddress && tx.to !== null);

    if (depositTx && externalInteractions.length > 0) {
      console.log('Potential exploit setup detected');
      const sequence = recentTxs.map(tx => `${tx.function}:${tx.to}`).join(' -> ');
      this.emit('potentialAttack', { type: 'reentrancy', sequence, latestTx });
      await this.reportSuspiciousSequence(sequence, 'Potential reentrancy exploit setup detected');
      await this.attemptHighPriorityPause(latestTx);
      await this.sendComprehensiveAlert(recentTxs);
    }
  }

  private async attemptHighPriorityPause(suspiciousTx: TransactionInfo) {
    const now = Date.now();
    if (now - this.lastPauseAttempt < this.PAUSE_COOLDOWN) {
      console.log(`[${new Date().toISOString()}] Pause attempt cooldown in effect. Skipping this attempt.`);
      return;
    }
    this.lastPauseAttempt = now;

    if (this.isContractPaused || this.pauseTransactionHash) {
      console.log(`[${new Date().toISOString()}] Pause already in progress or contract already paused. Skipping pause attempt.`);
      return;
    }

    console.log(`[${new Date().toISOString()}] Attempting high-priority pause...`);

    const maxAttempts = 5;
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      try {
        const signer = this.provider.getSigner();
        const address = await (await signer).getAddress();

        // Check if the contract is already paused
        const isPaused = await this.contract.paused();
        if (isPaused) {
          console.log(`[${new Date().toISOString()}] Contract is already paused.`);
          this.isContractPaused = true;
          return;
        }

        const suspiciousGasPrice = await this.provider.getTransaction(suspiciousTx.hash).then(tx => tx?.gasPrice || ethers.parseUnits('100', 'gwei'));
        const pauseGasPrice = suspiciousGasPrice * BigInt(300 + attempt * 100) / BigInt(100);

        console.log(`[${new Date().toISOString()}] Attempt ${attempt + 1}: Using gas price ${ethers.formatUnits(pauseGasPrice, 'gwei')} gwei`);

        const gasLimit = 500000;

        const pauseTx = await this.contract.connect(await signer).pause({
          gasLimit: gasLimit,
          gasPrice: pauseGasPrice,
        });

        this.pauseTransactionHash = pauseTx.hash;
        console.log(`[${new Date().toISOString()}] High-priority pause transaction sent: ${pauseTx.hash}`);

        const receipt = await pauseTx.wait(1);
        console.log(`[${new Date().toISOString()}] Contract pause transaction mined in block: ${receipt?.blockNumber}`);

        // Verify the pause was successful
        const finalPauseState = await this.contract.paused();
        if (finalPauseState) {
          console.log(`[${new Date().toISOString()}] Contract pause verified successfully.`);
          this.isContractPaused = true;
          return;
        } else {
          throw new Error('Contract pause transaction succeeded, but contract is not paused');
        }
      } catch (error) {
        console.error(`[${new Date().toISOString()}] Failed to pause contract (Attempt ${attempt + 1}):`, error);
        if (error instanceof Error) {
          console.error('Error message:', error.message);
          console.error('Error stack:', error.stack);
        }
        this.pauseTransactionHash = null;

        if (attempt === maxAttempts - 1) {
          console.log(`[${new Date().toISOString()}] Max attempts reached. Implementing fallback mechanism.`);
        } else {
          console.log(`[${new Date().toISOString()}] Retrying in 2 seconds...`);
          await new Promise(resolve => setTimeout(resolve, 2000));
        }
      }
    }
  }

  private async reportSuspiciousSequence(sequence: string, reason: string) {
    const report = `ALERT: ${reason}\nTransaction Sequence: ${sequence}`;
    console.log(report);
    this.suspiciousSequences.push(report);
    if (this.suspiciousSequences.length > this.SUSPICIOUS_SEQUENCE_LIMIT) {
      this.suspiciousSequences.shift();
    }

    await this.reportingService.logAlert('reentrancy', report);
  }

  private async sendComprehensiveAlert(suspiciousSequence: TransactionInfo[]) {
    const alertSubject = "URGENT: Potential Reentrancy Exploit Detected and Mitigated";

    let alertBody = `
  Potential reentrancy exploit detected and mitigated.
  
  Timestamp: ${new Date().toISOString()}
  
  Suspicious Transaction Sequence:
  ${suspiciousSequence.map((tx, index) => `
  ${index + 1}. Hash: ${tx.hash}
     From: ${tx.from}
     To: ${tx.to}
     Function: ${tx.function}
     Value: ${ethers.formatEther(tx.value)} ETH
  `).join('\n')}
  
  Action Taken: Contract has been paused.
  Pause Transaction: ${this.pauseTransactionHash}
  Pause Block: ${await this.provider.getTransactionReceipt(this.pauseTransactionHash!).then(receipt => receipt?.blockNumber)}
  
  Next Steps:
  1. Investigate the suspicious transactions thoroughly.
  2. Review and patch the smart contract if necessary.
  
  
  Please take immediate action to address this potential security threat.
  `;

    await this.sendEmailAlert(alertSubject, alertBody);
    console.log(`[${new Date().toISOString()}] Comprehensive alert sent.`);
  }

  private async sendEmailAlert(subject: string, content: string) {
    if (!this.emailTransporter) {
      console.warn('Email transporter not set up. Skipping email alert.');
      return;
    }

    const { EMAIL_FROM, EMAIL_TO } = process.env;

    if (!EMAIL_FROM || !EMAIL_TO) {
      console.warn('Email sender or recipient not set. Skipping email alert.');
      return;
    }

    try {
      await this.emailTransporter.sendMail({
        from: EMAIL_FROM,
        to: EMAIL_TO,
        subject: subject,
        text: content
      });
      console.log(`[${new Date().toISOString()}] Email alert sent successfully`);
    } catch (error) {
      console.error(`[${new Date().toISOString()}] Error sending email alert:`, error);
    }
  }

  public async getSuspiciousSequences(): Promise<string[]> {
    return this.suspiciousSequences;
  }
}