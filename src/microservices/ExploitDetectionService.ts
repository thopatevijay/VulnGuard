import { ethers } from 'ethers';
import { VulnerableBank } from '../../typechain-types';
import nodemailer from 'nodemailer';
import dotenv from 'dotenv';
import EventEmitter from 'events';
import { ReportingService } from './ReportingService';
import kleur from 'kleur';

dotenv.config();

type Transaction = ethers.TransactionResponse;
interface TransactionInfo {
  hash: string;
  from: string;
  to: string | null;
  value: bigint;
  function: string;
  timestamp: number;
  data: string;
}

export class ExploitDetectionService extends EventEmitter {
  private provider: ethers.JsonRpcProvider;
  private contract: VulnerableBank;
  private contractAddress: string;
  private recentTransactions: TransactionInfo[] = [];
  private suspiciousSequences: string[] = [];
  private readonly TRANSACTION_HISTORY_LIMIT = 50;
  private readonly SUSPICIOUS_SEQUENCE_LIMIT = 10;
  private readonly TIME_WINDOW = 30000; // 30 seconds
  private emailTransporter: nodemailer.Transporter | null = null;
  private reportingService: ReportingService;

  constructor(provider: ethers.JsonRpcProvider, contract: VulnerableBank, reportingService: ReportingService) {
    super();
    this.provider = provider;
    this.contract = contract;
    this.contractAddress = '';
    this.reportingService = reportingService;
    this.setupEmailTransporter();
  }

  private setupEmailTransporter() {
    const { EMAIL_HOST, EMAIL_PORT, EMAIL_SECURE, EMAIL_USER, EMAIL_PASS } = process.env;

    if (EMAIL_HOST && EMAIL_USER && EMAIL_PASS) {
      this.emailTransporter = nodemailer.createTransport({
        host: EMAIL_HOST,
        port: parseInt(EMAIL_PORT || '587'),
        secure: EMAIL_SECURE === 'true',
        auth: {
          user: EMAIL_USER,
          pass: EMAIL_PASS
        }
      });
      console.log(kleur.green('Email transporter set up successfully'));
    } else {
      console.warn(kleur.yellow('Email configuration not set. Email alerts will not be sent.'));
    }
  }

  async startMonitoring() {
    console.log(kleur.blue().bold('Starting to monitor transactions...'));

    try {
      this.contractAddress = await this.contract.getAddress();
      console.log(kleur.blue(`Monitoring contract at address: ${this.contractAddress}`));

      this.provider.on('pending', (txHash) => this.analyzePendingTransaction(txHash).catch(console.error));

      console.log(kleur.green('Transaction monitoring set up successfully'));
    } catch (error) {
      console.error(kleur.red('Error setting up transaction monitoring:'), error);
    }
  }

  private async analyzePendingTransaction(txHash: string) {
    try {
      const tx = await this.provider.getTransaction(txHash);
      if (tx) {
        const txInfo = await this.getTransactionInfo(tx);
        this.logTransactionDetails(txInfo);
        this.updateTransactionHistory(txInfo);
        await this.detectPotentialExploit(txInfo);
        await this.reportingService.logTransaction(txInfo);
      }
    } catch (error) {
      console.error(kleur.red(`Error analyzing pending transaction ${txHash}:`), error);
    }
  }

  private async getTransactionInfo(tx: Transaction): Promise<TransactionInfo> {
    const isToVulnerableBank = tx.to?.toLowerCase() === this.contractAddress.toLowerCase();
    let functionName = 'Unknown';

    if (isToVulnerableBank) {
      const decodedData = this.contract.interface.parseTransaction({ data: tx.data, value: tx.value });
      functionName = decodedData?.name || 'Unknown';
    } else if (!tx.to) {
      functionName = 'Contract Deployment';
    }

    return {
      hash: tx.hash,
      from: tx.from,
      to: tx.to,
      value: tx.value,
      function: functionName,
      timestamp: Date.now(),
      data: tx.data
    };
  }

  private logTransactionDetails(txInfo: TransactionInfo) {
    console.log(kleur.cyan().bold('\nTransaction Details:'));
    console.log(kleur.cyan(`  Hash: ${txInfo.hash}`));
    console.log(kleur.cyan(`  From: ${txInfo.from}`));
    console.log(kleur.cyan(`  To: ${txInfo.to}`));
    console.log(kleur.cyan(`  Function: ${txInfo.function}`));
    console.log(kleur.cyan(`  Value: ${ethers.formatEther(txInfo.value)} ETH`));
  }

  private updateTransactionHistory(txInfo: TransactionInfo) {
    this.recentTransactions.push(txInfo);
    if (this.recentTransactions.length > this.TRANSACTION_HISTORY_LIMIT) {
      this.recentTransactions.shift();
    }
  }

  private async detectPotentialExploit(latestTx: TransactionInfo) {
    const recentTxs = this.recentTransactions.filter(tx =>
      tx.timestamp >= latestTx.timestamp - this.TIME_WINDOW &&
      tx.from === latestTx.from
    );

    console.log(kleur.blue('Recent transactions:'), recentTxs.map(tx => `${tx.function} to ${tx.to}`));

    const depositTx = recentTxs.find(tx => tx.function === 'deposit' && tx.to === this.contractAddress);
    const externalInteractions = recentTxs.filter(tx => tx.to !== this.contractAddress && tx.to !== null);

    if (depositTx && externalInteractions.length > 0) {
      console.log(kleur.yellow().bold('Potential exploit setup detected'));
      const sequence = recentTxs.map(tx => `${tx.function}:${tx.to}`).join(' -> ');
      this.emit('potentialExploitDetected', { type: 'reentrancy', sequence, suspiciousTransactions: recentTxs });
      await this.reportSuspiciousSequence(sequence, 'Potential reentrancy exploit setup detected');
      await this.sendImmediateAlert(recentTxs);
    }
  }

  private async reportSuspiciousSequence(sequence: string, reason: string) {
    const report = `ALERT: ${reason}\nTransaction Sequence: ${sequence}`;
    console.log(kleur.yellow().bold(report));
    this.suspiciousSequences.push(report);
    if (this.suspiciousSequences.length > this.SUSPICIOUS_SEQUENCE_LIMIT) {
      this.suspiciousSequences.shift();
    }

    await this.reportingService.logAlert('reentrancy', report);
  }

  private async sendImmediateAlert(suspiciousTransactions: TransactionInfo[]) {
    const alertSubject = "URGENT: Potential Reentrancy Exploit Detected";

    let alertBody = `
      Potential reentrancy exploit detected.

      Timestamp: ${new Date().toISOString()}

      Suspicious Transaction Sequence:
      ${suspiciousTransactions.map((tx, index) => `
      ${index + 1}. Hash: ${tx.hash}
         From: ${tx.from}
         To: ${tx.to}
         Function: ${tx.function}
         Value: ${ethers.formatEther(tx.value)} ETH
      `).join('\n')}

      Action Being Taken: Notifying prevention service.

      Next Steps:
      1. Monitor the contract status for potential pausing.
      2. Investigate the suspicious transactions thoroughly.
      3. Develop a plan to safely mitigate the vulnerability.

      Please take immediate action to address this potential security threat.
      `;

    await this.sendEmailAlert(alertSubject, alertBody);
    console.log(kleur.green(`[${new Date().toISOString()}] Immediate alert sent.`));
  }

  private async sendEmailAlert(subject: string, content: string) {
    if (!this.emailTransporter) {
      console.warn(kleur.yellow('Email transporter not set up. Skipping email alert.'));
      return;
    }

    const { EMAIL_FROM, EMAIL_TO } = process.env;

    if (!EMAIL_FROM || !EMAIL_TO) {
      console.warn(kleur.yellow('Email sender or recipient not set. Skipping email alert.'));
      return;
    }

    try {
      await this.emailTransporter.sendMail({
        from: EMAIL_FROM,
        to: EMAIL_TO,
        subject: subject,
        text: content
      });
      console.log(kleur.green(`[${new Date().toISOString()}] Email alert sent successfully`));
    } catch (error) {
      console.error(kleur.red(`[${new Date().toISOString()}] Error sending email alert:`), error);
    }
  }

  public async getSuspiciousSequences(): Promise<string[]> {
    return this.suspiciousSequences;
  }
}